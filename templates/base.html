<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{% block title %}Formula Booklets{% endblock %}</title>

    <!-- Bootswatch (Bootstrap 5) - Brite theme (local) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.css') }}" />
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-primary" data-bs-theme="light">
      <div class="container">
        <a class="navbar-brand text-dark" href="{{ url_for('index') }}">Formula Booklets</a>

        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarColor01"
          aria-controls="navbarColor01"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarColor01">
          <ul class="navbar-nav me-auto">
            <li class="nav-item">
              <a
                class="nav-link text-dark {% if active_page == 'home' %}active{% endif %}"
                href="{{ url_for('index') }}"
              >
                Home
                {% if active_page == 'home' %}
                  <span class="visually-hidden">(current)</span>
                {% endif %}
              </a>
            </li>
            <li class="nav-item">
              <a
                class="nav-link text-dark {% if active_page == 'contact' %}active{% endif %}"
                href="{{ url_for('contact') }}"
              >
                Contact
              </a>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <main class="container py-4">
      {% block content %}{% endblock %}
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      (function () {
        const cards = document.querySelectorAll('[data-fx="glow-matrix"]');
        if (!cards.length) return;

        const DIGITS = '0123456789';
        const BUBBLE_COUNT = 25;
        const BUBBLE_SIZE_MIN = 10;
        const BUBBLE_SIZE_MAX = 25;
        const BUBBLE_STAGGER_DURATION = 2;
        const BUBBLE_RISE_DURATION_MIN = 5;
        const BUBBLE_RISE_DURATION_MAX = 7;
        const BUBBLE_SWAY_DURATION_MIN = 3;
        const BUBBLE_SWAY_DURATION_MAX = 5;

        function buildDigits(rows, cols) {
          let out = '';
          for (let r = 0; r < rows; r++) {
            let line = '';
            for (let c = 0; c < cols; c++) {
              // sprinkle spaces so it feels subtle
              const roll = Math.random();
              if (roll < 0.22) line += ' ';
              else line += DIGITS[(Math.random() * DIGITS.length) | 0];
            }
            out += line + (r === rows - 1 ? '' : '\n');
          }
          return out;
        }

        function measureCharWidth(sampleEl) {
          const probe = document.createElement('span');
          const styles = getComputedStyle(sampleEl);
          probe.style.position = 'absolute';
          probe.style.left = '-9999px';
          probe.style.top = '0';
          probe.style.whiteSpace = 'pre';
          probe.style.fontFamily = styles.fontFamily;
          probe.style.fontSize = styles.fontSize;
          probe.style.fontWeight = styles.fontWeight;
          probe.style.letterSpacing = styles.letterSpacing;
          probe.textContent = '0000000000';
          document.body.appendChild(probe);
          const w = probe.getBoundingClientRect().width / 10;
          probe.remove();
          return Math.max(1, w);
        }

        function createBubbles(container, count) {
          const bubbles = [];
          for (let i = 0; i < count; i++) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            const size = Math.random() * (BUBBLE_SIZE_MAX - BUBBLE_SIZE_MIN) + BUBBLE_SIZE_MIN;
            bubble.style.width = size + 'px';
            bubble.style.height = size + 'px';
            bubble.style.left = Math.random() * 100 + '%';
            // Start bubbles at different heights for immediate visual effect
            const startDelay = (i / count) * BUBBLE_STAGGER_DURATION;
            const swayDelay = Math.random() * (BUBBLE_SWAY_DURATION_MAX - BUBBLE_SWAY_DURATION_MIN);
            bubble.style.animationDelay = startDelay + 's, ' + swayDelay + 's';
            const riseDuration = Math.random() * (BUBBLE_RISE_DURATION_MAX - BUBBLE_RISE_DURATION_MIN) + BUBBLE_RISE_DURATION_MIN;
            const swayDuration = Math.random() * (BUBBLE_SWAY_DURATION_MAX - BUBBLE_SWAY_DURATION_MIN) + BUBBLE_SWAY_DURATION_MIN;
            bubble.style.animationDuration = riseDuration + 's, ' + swayDuration + 's';
            container.appendChild(bubble);
            bubbles.push(bubble);
          }
          return bubbles;
        }

        for (const card of cards) {
          const matrix = card.querySelector('.fx-matrix');
          const isChemistry = card.dataset.subject === 'Chemistry';
          let timer = null;
          let clearTimer = null;
          let bubbles = [];

          function setGlowFromEvent(evt) {
            const rect = card.getBoundingClientRect();
            const x = ((evt.clientX - rect.left) / rect.width) * 100;
            const y = ((evt.clientY - rect.top) / rect.height) * 100;
            card.style.setProperty('--glow-x', x.toFixed(2) + '%');
            card.style.setProperty('--glow-y', y.toFixed(2) + '%');
          }

          card.addEventListener('mousemove', setGlowFromEvent);
          card.addEventListener('mouseenter', (evt) => {
            setGlowFromEvent(evt);
            if (!matrix) return;

            if (clearTimer) {
              clearTimeout(clearTimer);
              clearTimer = null;
            }

            if (isChemistry) {
              // Clear existing bubbles before creating new ones
              bubbles.forEach(b => b.remove());
              bubbles = [];
              // Create animated bubbles for Chemistry card
              bubbles = createBubbles(matrix, BUBBLE_COUNT);
            } else {
              // Estimate density based on card size
              const rect = card.getBoundingClientRect();
              const ms = getComputedStyle(matrix);
              const padX = parseFloat(ms.paddingLeft) + parseFloat(ms.paddingRight);
              const padY = parseFloat(ms.paddingTop) + parseFloat(ms.paddingBottom);
              const charW = measureCharWidth(matrix);
              const cols = Math.max(22, Math.floor((rect.width - padX) / charW));
              const rows = Math.max(8, Math.floor((rect.height - padY) / 18));

              if (timer) clearInterval(timer);
              matrix.textContent = buildDigits(rows, cols);
              timer = setInterval(() => {
                matrix.textContent = buildDigits(rows, cols);
              }, 80);
            }
          });

          card.addEventListener('mouseleave', () => {
            if (timer) {
              clearInterval(timer);
              timer = null;
            }
            if (matrix) {
              // Let opacity transition handle the fade-out; clear after.
              if (clearTimer) clearTimeout(clearTimer);
              clearTimer = setTimeout(() => {
                if (isChemistry) {
                  bubbles.forEach(b => b.remove());
                  bubbles = [];
                } else {
                  matrix.textContent = '';
                }
                clearTimer = null;
              }, 260);
            }
          });
        }
      })();
    </script>
  </body>
</html>
